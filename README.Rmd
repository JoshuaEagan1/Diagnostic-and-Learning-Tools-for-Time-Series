---
title: "Diagnostic and Learning Tools for Time Series"
author: "Joshua Eagan"
date: "December 12, 2020"
output: rmarkdown::github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(TSA)
library(reshape2)
library(tidyverse)

ar1.acf<-function(x, true_ar, lag.max=NULL, pvalue=.05){
        z <- qnorm(1-(pvalue/2))
        acf_vals<-as.vector(TSA::acf(x, lag.max=lag.max, plot=F)$acf)
        lag.max<-length(acf_vals)
        k<-1:lag.max
        var<-((1 - (acf_vals^(2*k)))*(1 + (acf_vals^2))*((1 - (acf_vals^2))^-1))-(2*k*(acf_vals^(2*k)))
        confband <- matrix(NA,2,lag.max)
        for (i in 1:2){
                confband[i,] <- (acf_vals + c(-1,1)[i]*z*sqrt(var/length(x)))}
        matplot(k,t(confband),type="l",lty=c(2,2,1),col="blue",ylab=expression(rho[k]), ylim=c(min(confband)-.1, max(confband)+.1), xlab="lags")
        abline(0,0)
        true_vals<-as.vector(ARMAacf(ar=true_ar, lag.max=lag.max)[2:lag.max])
        for (i in 1:length(acf_vals)){
                points(i, true_vals[i])}
        title(paste0((1-pvalue)*100, "% ACF Confidence Intervals Against the True AR(1)"))
}

ma1.acf<-function(y, true_ma, lag.max=NULL, pvalue=.05){
        acf.out<-as.vector(acf(y, lag.max=lag.max, plot=F)$acf) #getting the sample acf values
        lag.max<-length(acf.out)
        p1<-acf.out[1]
        var<-(1/length(y))*(1-(3*p1^2)+(4*p1^4)) #calculating the variance for roh(1)
        var_oth<-(1/length(y))*(1+(2*p1^2)) #calculating the variance for roh > 1
        var<-append(var, rep(var_oth, lag.max-1))
        z <- qnorm(1-(pvalue/2))
        k <- 1:lag.max
        true_vals<-ARMAacf(ma=true_ma, lag.max = lag.max)[1:lag.max+1] #finding the theoretical autocorrelation function
        confband <- matrix(NA,2,lag.max)
        for (i in 1:2){
                confband[i,] <- (acf.out + c(-1,1)[i]*z*sqrt(var))
        }
        matplot(k,t(confband),type="l",lty=c(2,2,1),col="blue",ylab=expression(rho[k]), ylim=c(min(confband)-.1, max(confband)+.1))
        abline(0,0)
        for (i in 1:lag.max){
                points(i, true_vals[i])}
        title(paste0((1-pvalue)*100, "% ACF Confidence Intervals Against the True MA(1)"))
}

eacf_pic<-function(x, ar.max=7, ma.max = 13, text_pvals=F){

        n<-length(x)

        eacf_pvalue<-function(mat1, n, ar.max =ar.max, ma.max = ma.max){ 
                tstat<-matrix(c(rep(1,(ar.max+1)*(ma.max+1))), nrow = ar.max+1, ncol = ma.max+1)
                se<-matrix(c(rep(1,(ar.max+1)*(ma.max+1))), nrow = ar.max+1, ncol = ma.max+1)  
                pvalue<-matrix(c(rep(1,(ar.max+1)*(ma.max+1))), nrow = ar.max+1, ncol = ma.max+1)
                symbol<-matrix(c(rep(1,(ar.max+1)*(ma.max+1))), nrow = ar.max+1, ncol = ma.max+1)
                for (i in 1:(ar.max+1))
                        {
                        for (j in 1:(ma.max+1)) { 
                                se[i,j]<- 1/sqrt((n-i-j+2))
                                tstat[i,j]<-abs( mat1[i,j]/se[i,j])  
                                pvalue[i,j]<-2*(1-pnorm(tstat[i,j]))
                                }
                        }
                symbol<-ifelse(pvalue>.05,"o","x")
                rownames(pvalue)<-0:ar.max
                pvalue<-data.frame(pvalue)
                names(pvalue)<-0:ma.max
                pvalue
        }
        
        eacf<-function (z, ar.max = 7, ma.max = 13) 
        {
                lag1 <- function(z, lag = 1) {
                        c(rep(NA, lag), z[1:(length(z) - lag)])
                }
                reupm <- function(m1, nrow, ncol) {
                        k <- ncol - 1
                        m2 <- NULL
                        for (i in 1:k) {
                                i1 <- i + 1
                                work <- lag1(m1[, i])
                                work[1] <- -1
                                temp <- m1[, i1] - work * m1[i1, i1]/m1[i, i]
                                temp[i1] <- 0
                                m2 <- cbind(m2, temp)
                        }
                        m2
                }
                ceascf <- function(m, cov1, nar, ncol, count, ncov, z, zm) {
                        result <- 0 * seq(1, nar + 1)
                        result[1] <- cov1[ncov + count]
                        for (i in 1:nar) {
                                temp <- cbind(z[-(1:i)], zm[-(1:i), 1:i]) %*% c(1, 
                                                                                -m[1:i, i])
                                result[i + 1] <- acf(temp, plot = FALSE, lag.max = count, 
                                                     drop.lag.0 = FALSE)$acf[count + 1]
                        }
                        result
                }
                ar.max <- ar.max + 1
                ma.max <- ma.max + 1
                nar <- ar.max - 1
                nma <- ma.max
                ncov <- nar + nma + 2
                nrow <- nar + nma + 1
                ncol <- nrow - 1
                z <- z - mean(z)
                zm <- NULL
                for (i in 1:nar) zm <- cbind(zm, lag1(z, lag = i))
                cov1 <- acf(z, lag.max = ncov, plot = FALSE, drop.lag.0 = FALSE)$acf
                cov1 <- c(rev(cov1[-1]), cov1)
                ncov <- ncov + 1
                m1 <- matrix(0, ncol = ncol, nrow = nrow)
                for (i in 1:ncol) m1[1:i, i] <- ar.ols(z, order.max = i, 
                                                       aic = FALSE, demean = FALSE, intercept = FALSE)$ar
                eacfm <- NULL
                for (i in 1:nma) {
                        m2 <- reupm(m1 = m1, nrow = nrow, ncol = ncol)
                        ncol <- ncol - 1
                        eacfm <- cbind(eacfm, ceascf(m2, cov1, nar, ncol, i, 
                                                     ncov, z, zm))
                        m1 <- m2
                }
                work <- 1:(nar + 1)
                work <- length(z) - work + 1
                symbol <- NULL
                for (i in 1:nma) {
                        work <- work - 1
                        symbol <- cbind(symbol, ifelse(abs(eacfm[, i]) > 2/work^0.5, 
                                                       "x", "o"))
                }
                rownames(symbol) <- 0:(ar.max - 1)
                colnames(symbol) <- 0:(ma.max - 1)
                invisible(list(eacf = eacfm, ar.max = ar.max, ma.ma = ma.max, 
                               symbol = symbol))
        }

        out=invisible(eacf(x, ar.max=ar.max, ma.max=ma.max))
        epo<-eacf_pvalue(out$eacf, n, ar.max=ar.max, ma.max=ma.max)
        m <- melt(epo)
        m$pvalue<-round(m$value, 2)
        m<-cbind(m, rep(0:ar.max, ma.max+1))
        names(m)<-c("rows","value","pvalue", "columns")
        Spectrum<-c()
        for(i in 1:nrow(m)){
                if(m$value[i]<=.001){
                        Spectrum[i]<-"P </= .001"
                } else if(m$value[i]<=.01){
                        Spectrum[i]<-".001 < P </= .01"
                } else if(m$value[i]<=.05){
                        Spectrum[i]<-".01 < P </= .05"
                } else if(m$value[i]<=.1){
                        Spectrum[i]<-".05 < P </= .10"
                } else if(m$value[i]<=.2){
                        Spectrum[i]<-".10 < P </= .20"
                } else if(m$value[i]>.2){
                        Spectrum[i]<-".P > .20"
                }
        }
        Spectrum <- factor(Spectrum, levels = c("P </= .001", ".001 < P </= .01",
                ".01 < P </= .05",  ".05 < P </= .10",  ".10 < P </= .20",  ".P > .20"))
        m<-cbind(m, Spectrum)
        rm(Spectrum)
        
        p<-ggplot(m, aes(x = rows, y = reorder(columns, desc(columns)))) +
                geom_tile(aes(fill = Spectrum), colour="black", show.legend=T) +
                scale_fill_manual(values= c("#EF3B2C", "#FB6A4A", "#FC9272", "#BDBDBD", "#737373", "#525252"))+
                scale_x_discrete(position = "top")+
                labs(title="Extended Autocorrelation Function (EACF)", caption = "Smaller P-values are shown in red. P-values above .05 are shown in grey.")+
                xlab("Moving Average (MA)")+
                ylab("Autoregressive (AR)")+
                theme_bw()
        
        if(text_pvals){
                p + geom_text(aes(label=pvalue), color="black", size=rel(4.5))
        } else {
                p
        }
}

ar1.est<-function(x){
        model <- arima(x,order=c(1,0,0))
        z <- qnorm(.975)
        k <- 1:10
        confband <- matrix(NA,2,10)
        for (i in 1:2){
                #(the estimated AR coefficient from the model +/- (1.96 * sqrt(estimated variance of AR parameter)))^lag
                confband[i,] <- (model$coef[1] + c(-1,1)[i]*z*sqrt(model$var.coef[1,1]))^k}
        acf_vals<-TSA::acf(x, plot=F)$acf
        acf_vals<-acf_vals[1:10]
        matplot(k,t(confband),type="l",lty=c(2,2,1),col="blue",ylab=expression(rho[k]), ylim=c(min(confband)-.1, max(confband)+.1))
        abline(0,0)
        for (i in 1:length(acf_vals)){
                segments(i,0, i, acf_vals[i])}
        title("ACF with Confidence Intervals for AR(1)")
}

```

## Project Summary

The R functions in this directory will be useful in teaching students of time series analysis who are beginning applied work with ARMA(p,q) models and for more seasoned time series analysts looking for improved diagnostic tools.

[RPubs project write up](https://rpubs.com/Jmemq7/705674)

----------------------------------------------------------------------------------------------

## Functions for Learning Time Series

The `ar1.acf()` and `ma1.acf()`functions are designed to help students learn how to use a graph of the autocorrelation function of a timeseries to decide whether MA(1) or AR(1) models are the right choice to use in forcasting future values.

### ar1.acf

This function takes a time series and computes confidence intervals around its ACF on the assumption that its autocorrelation suggests the AR(1) model is appropriate. It uses variances from Bartlett's Approximation, shown below.

![Alt text](C:/Users/Josh/Desktop/TS analysis/final project/Diagnostic and Learning Tools for Time Series/equasions/1.png)

For the AR(1) process, this simplifies down to:

![Alt text](C:/Users/Josh/Desktop/TS analysis/final project/Diagnostic and Learning Tools for Time Series/equasions/2.png)
for  = 1,2, ... where phi is the sample autocorrelation at lag tau

The actual confidence intervals are calculated using the following formula:

![Alt text](C:/Users/Josh/Desktop/TS analysis/final project/Diagnostic and Learning Tools for Time Series/equasions/3.png)

The confidence intervals can be compared against theoretical autocorrelation values of an AR(1) parameter provided by the user. `ar1.acf()` uses `ARMAacf()` to retreive the theoretical autocorrelations.

The `ar1.acf()` function takes the following inputs:

* **x**         time series (object with the class `ts`) to be tested against theoretical autocorrelation function values. Confidence intervals will be estimated around the estimated autocorrelation function of this series.
* **true_ar**   autoregressive parameter to generate a theoretical autocorrelation function to be compared against the provided time series
* **lag.max=NULL**   maximum number of lags to estimate autocorrelation (defaults to a number of lags chosen by the ACF function based on the length of the series)
* **pvalue=.05**    p-value desired for the confidence intervals around the autocorrelation function of **x**

```{r}
#loading in the required TSA package
library(TSA)

#simulating an AR(1) time series
set.seed(1406565)
true_ar<-.8
x <- arima.sim(n=100,model=list(ar=true_ar))

#run
ar1.acf(x, true_ar = true_ar, lag.max=10)


```

The dots in the graph are the values from the true autocorrelation of an AR(1) series with the parameter p=.8. The confidence intervals are fit around the true autocorrelation of x using u where alpha (the pvalue) was .05.

Notes:

* The function will not work correctly unless the `TSA` package is loaded.
* The `pvalue` argument automatically updates the title. 
* You can use this function on data for which the true ar(1) parameter is unknown. The true autocorrelation can only be known in the case of simulated data, which was done in this case to show how the function works.

### ma1.acf

Much like `ar1.acf`, this function takes a time series, finds its ACF, and computes confidence intervals around the ACF testing the assumption that the data is an MA(1) series using variances from Bartlett's Approximation (shown above.)

For the MA(1) case, Bartlett's Approximation simplifies to the following:

![Alt text](C:/Users/Josh/Desktop/TS analysis/final project/Diagnostic and Learning Tools for Time Series/equasions/4.png)
     
As above, the confidence intervals around the sample ACF are computed using the formula below.

![Alt text](C:/Users/Josh/Desktop/TS analysis/final project/Diagnostic and Learning Tools for Time Series/equasions/5.png)

The `ma1.acf()` function takes the following inputs:

* **y** time series (object with the class `ts`) to be tested against theoretical autocorrelation function values. Confidence intervals will be estimated around the estimated autocorrelation function of this series.
* **true_ma** MA parameter to generate a theoretical autocorrelation function for comparison against the ACF of **y**
* **lag.max=NULL**   maximum number of lags to estimate autocorrelation (defaults to a number of lags chosen by the ACF function based on the length of the series)
* **pvalue=.05** p-value desired for the confidence intervals around the autocorrelation function of **y**

```{r}
#loading the required TSA package
library(TSA)

#simulating an MA(1) time series
set.seed(240)
true_ma<-.8
y <- arima.sim(n=100,model=list(ma=true_ma))

#run
ma1.acf(y, true_ma=true_ma)

```

The dots in the graph are the values from the true autocorrelation of an MA(1) series with the parameter q=.8. The confidence intervals are fit around the true autocorrelation of y using u where alpha (the pvalue) was .05.

Notes:

* The function will not work correctly unless the `TSA` package is loaded.
* The `pvalue` argument automatically updates the title. 
* You can use this function on data for which the true ma(1) parameter is unknown. The true autocorrelation can only be known in the case of simulated data, which was done in this case to show how the function works.

----------------------------------------------------------------------------------------------

## Diagnostic Tools

`eacf_pic()` and `ar1.est()` are a pair of functions which will be more useful in an applied setting where you don't have the ability to know the true ARMA(p,q) order underlying a timeseries.

### eacf_pic

The `eacf_pic()` function produces a visualization of the sample extended autocorrelation function using [geom_tile()](https://ggplot2.tidyverse.org/reference/geom_tile.html) in the `ggplot2` package. The main value added of this in comparison to the [eacf()](https://www.rdocumentation.org/packages/TSA/versions/1.3/topics/eacf) function in the `TSA` package is that rather than a binary indicator significance, "X" or "O", being displayed in the console, this function produces a picture of the eacf that clearly shows significance using colors (red tiles are significant at the 5% level and grey tiles are insignificant) while also indicating the level of significance using color intensity.

`eacf_pic()` function takes the following inputs:

* **x**                 time series object for which to produce the eacf
* **ar.max=7**          maximum number of autoregressive coefficients to test
* **ma.max = 13**       maximum number of moving average coefficients to test
* **text_pvals=F**      an option to add p-values rounded to the nearest hundreth to the tiles

```{r}
#loading required libraries
library(TSA)
library(reshape2)
library(tidyverse)

#simulating some time series data
set.seed(243)
x=arima.sim(n = 500, list(ar = c(0.8897, -0.4858), ma = c(-0.2279, 0.2488)), sd = sqrt(0.1796))

#run
eacf_pic(x)

#the output of the eacf function from the TSA package
eacf(x)

```

Notes:

* The function will not work correctly unless the `TSA`, `reshape2`, and `tidyverse` packages are loaded.
* You will always receive the message `No id variables; using all as measure variables`. This is not an error, it is automatically printed by the `melt()` function in `reshape2`.
* A careful reader might notice that there is no color to represent the p-value threshhold $.10 < P </= .20$. This is because there are no such values in our example graph, so it was ommitted in the legend.
* The text p-values might be helpful to some, but they are generally undesirable due to the neccecity to round to the nearest hundreth. This makes p-values below .005 appear as 0.


### AR(1) Diagnostic tool: 

Inspired by a [Stack Exchange post](https://stats.stackexchange.com/questions/310470/lag-wise-confidence-band-for-sample-autocorrelation-function-of-ar1-process#310578), this function automates an answer given to the problem of computing lag-wise confidence bands for the sample autocorrelation function of an AR(1) process. This function is potentially a better solution than `ar1_acf` in an applied setting where the time series is an AR(1) process but the true autocorrelation is not known.

The `ar1.est()` function takes only 1 input:

* **x** a time series suspected to be an AR(1) series.

```{r}
#loading required package
library(TSA)

#simulating an AR(1) process
set.seed(25)
x <- arima.sim(n=100,model=list(ar=-.8))

#run
ar1.est(x)
```

## Credit

Each of these functions are built using functions from the [TSA](https://CRAN.R-project.org/package=TSA) package as well as functions included in base R. The `eacf_pic()` function relies on a function in [ggplot2](https://www.rdocumentation.org/packages/ggplot2/versions/3.3.2) as well as one in [reshape2](https://www.rdocumentation.org/packages/reshape2/versions/1.4.4). I leaned on [this post](https://stats.stackexchange.com/questions/310470/lag-wise-confidence-band-for-sample-autocorrelation-function-of-ar1-process#310578) for the creation of `ar1.est` and for some of the syntax for plotting the `ar1.acf` and `ma1.acf` functions. Special thanks to [Dr. Lori Thombs](http://faculty.missouri.edu/~thombsl/) for her guidance on this project and for her ideas to write the first three functions in this document.
